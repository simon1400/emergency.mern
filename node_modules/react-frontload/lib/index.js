'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.frontloadConnect = exports.Frontload = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.frontloadServerRender = frontloadServerRender;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var autoDetectIsServer = function autoDetectIsServer() {
  return typeof window === 'undefined' || !window.document || !window.document.createElement;
};

var IS_SERVER = autoDetectIsServer();

var SERVER_FRONTLOAD_QUEUE = [];

var LIFECYCLE_PHASES = {
  MOUNT: 0,
  UPDATE: 1
};

var log = process.env.NODE_ENV !== 'production' && function (name, message) {
  console.log('[react-frontload]' + (name ? ' [' + name + ']' : '') + ' ' + message);
};

var map = function map(arr, fn) {
  var mapped = [];

  for (var i = 0; i < arr.length; i++) {
    mapped.push(fn(arr[i], i));
  }

  return mapped;
};

var waitForAllToComplete = function waitForAllToComplete(promises) {
  return Promise.all(map(promises, function (promise) {
    return promise['catch'](function (error) {
      return error;
    });
  }));
};

var Frontload = exports.Frontload = function (_React$Component) {
  _inherits(Frontload, _React$Component);

  _createClass(Frontload, [{
    key: 'getChildContext',
    value: function getChildContext() {
      var _this2 = this;

      return {
        frontload: {
          isServer: this.isServer,
          firstClientRenderDone: this.isServer ? true : this.firstClientRenderDone,

          pushFrontload: function pushFrontload(frontload, options, lifecylePhase, childProps, logMessage) {
            var isMount = lifecylePhase === LIFECYCLE_PHASES.MOUNT;
            var isUpdate = lifecylePhase === LIFECYCLE_PHASES.UPDATE;
            var noServerRender = _this2.props.noServerRender || options.noServerRender;

            if (_this2.isServer && noServerRender || isMount && options.onMount === false || isUpdate && !options.onUpdate) {
                return;
              }

            if (_this2.isServer) {
              SERVER_FRONTLOAD_QUEUE.unshift({
                fn: function fn() {
                  return frontload(childProps, { isMount: isMount, isUpdate: isUpdate });
                },
                options: options,
                componentDisplayName: childProps.displayName
              });

              if (process.env.NODE_ENV !== 'production' && _this2.props.withLogging && logMessage) {
                log(_this2.props.name, 'added frontload fn to queue ' + logMessage);
              }
            } else if (noServerRender || _this2.firstClientRenderDone) {
              frontload(childProps, { isMount: isMount, isUpdate: isUpdate });

              if (process.env.NODE_ENV !== 'production' && _this2.props.withLogging && logMessage) {
                log(_this2.props.name, 'executed frontload fn ' + logMessage);
              }
            } else if (process.env.NODE_ENV !== 'production' && _this2.props.withLogging && logMessage) {
              log(_this2.props.name, 'did not execute frontload fn on first client render ' + logMessage + ', since server rendering is enabled');
            }
          }
        }
      };
    }
  }]);

  function Frontload(props, context) {
    _classCallCheck(this, Frontload);

    var _this = _possibleConstructorReturn(this, (Frontload.__proto__ || Object.getPrototypeOf(Frontload)).call(this, props, context));

    _this.isServer = props.isServer === undefined ? IS_SERVER : props.isServer;

    _this.componentDidMount = function () {
      _this.firstClientRenderDone = true;

      if (process.env.NODE_ENV !== 'production' && props.withLogging && !props.noServerRender) {
        log(props.name, '1st client render done, from now on all frontloads will run');
      }
    };
    return _this;
  }

  _createClass(Frontload, [{
    key: 'render',
    value: function render() {
      return _react2.default.Children.only(this.props.children);
    }
  }]);

  return Frontload;
}(_react2.default.Component);

Frontload.childContextTypes = {
  frontload: _propTypes2.default.object
};

var FrontloadConnectedComponent = function (_React$Component2) {
  _inherits(FrontloadConnectedComponent, _React$Component2);

  function FrontloadConnectedComponent(props, context) {
    _classCallCheck(this, FrontloadConnectedComponent);

    var _this3 = _possibleConstructorReturn(this, (FrontloadConnectedComponent.__proto__ || Object.getPrototypeOf(FrontloadConnectedComponent)).call(this, props, context));

    _this3.pushFrontload = function (lifecyclePhase, isServer) {
      return function () {
        var logMessage = process.env.NODE_ENV !== 'production' ? null : 'for component: [' + (_this3.props.component.displayName || 'anonymous') + '] on [' + (lifecyclePhase === LIFECYCLE_PHASES.MOUNT ? 'mount' : 'update') + ']';

        _this3.context.frontload.pushFrontload(_this3.props.frontload, _this3.props.options, lifecyclePhase, _this3.props.componentProps, logMessage);
      };
    };

    if (context.frontload.isServer) {
      _this3.componentWillMount = _this3.pushFrontload(LIFECYCLE_PHASES.MOUNT, true);
    } else {
      _this3.componentDidMount = _this3.pushFrontload(LIFECYCLE_PHASES.MOUNT);
      _this3.componentDidUpdate = _this3.pushFrontload(LIFECYCLE_PHASES.UPDATE);
    }
    return _this3;
  }

  _createClass(FrontloadConnectedComponent, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(this.props.component, this.props.componentProps);
    }
  }]);

  return FrontloadConnectedComponent;
}(_react2.default.Component);

FrontloadConnectedComponent.contextTypes = {
  frontload: _propTypes2.default.object
};
var frontloadConnect = exports.frontloadConnect = function frontloadConnect(frontload) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (component) {
    return function (props) {
      return _react2.default.createElement(FrontloadConnectedComponent, {
        frontload: frontload,
        component: component,
        componentProps: props,
        options: options
      });
    };
  };
};

function dryRunRender(renderFunction) {
  renderFunction(true);

  var frontloadsFromRender = SERVER_FRONTLOAD_QUEUE;
  SERVER_FRONTLOAD_QUEUE = [];

  return frontloadsFromRender;
}

function runAllFrontloads(frontloads) {
  return waitForAllToComplete(map(frontloads, function (frontload) {
    return frontload.fn();
  }));
}

function finalRender(renderFunction) {
  var renderOutput = renderFunction(false);

  SERVER_FRONTLOAD_QUEUE = [];

  return renderOutput;
}

function frontloadServerRenderWorker(render, _ref) {
  var withLogging = _ref.withLogging,
      maxNestedFrontloadComponents = _ref.maxNestedFrontloadComponents;
  var renderNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var frontloadsInLastRender = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  if (process.env.NODE_ENV !== 'production' && withLogging) {
    log('frontloadServerRender info', 'running render pass ' + renderNumber);
  }

  var frontloadsFromRender = dryRunRender(render);

  var frontloadsInThisRender = frontloadsFromRender.length + 0;
  var newFrontloadsInThisRender = frontloadsInThisRender - frontloadsInLastRender;

  if (process.env.NODE_ENV !== 'production' && withLogging) {
    log('frontloadServerRender info', 'render pass ' + renderNumber + ' - total frontloads count ' + newFrontloadsInThisRender);
  }

  if (!newFrontloadsInThisRender) {
    if (process.env.NODE_ENV !== 'production' && withLogging) {
      log('frontloadServerRender info', 'after running ' + renderNumber + ' render passes (of max ' + maxNestedFrontloadComponents + ' allowed) no frontload components remain to render, so running final render.');
    }

    var finalRenderOutput = finalRender(render);

    if (process.env.NODE_ENV !== 'production' && withLogging) {
      log('frontloadServerRender info', 'NOTE: as the logs show, the queue(s) are filled by Frontload on final render, however they are NOT flushed, so the frontload functions DO NOT run unnecessarily on final render.');
      log('frontloadServerRender info', 'final render succeeded. Server rendering is done.');
    }

    return Promise.resolve(finalRenderOutput);
  }

  if (process.env.NODE_ENV !== 'production' && withLogging) {
    log('frontloadServerRender info', frontloadsInThisRender + ' frontloads (' + newFrontloadsInThisRender + ' new) to run in render pass ' + renderNumber);
  }

  var startRunAllFrontloadsAt = withLogging && Date.now();

  return runAllFrontloads(frontloadsFromRender).then(function () {
    if (process.env.NODE_ENV !== 'production' && withLogging) {
      log('frontloadServerRender info', 'render pass ' + renderNumber + ' - ran ' + frontloadsInThisRender + ' frontloads (' + newFrontloadsInThisRender + ' new) in ' + (Date.now() - startRunAllFrontloadsAt) + 'ms');
    }

    if (renderNumber === maxNestedFrontloadComponents) {
      var incompleteRenderOutput = render(false);

      var frontloadsFromFinalRenderPass = SERVER_FRONTLOAD_QUEUE.length + 0;
      var frontloadsLeftToRun = frontloadsFromFinalRenderPass - frontloadsInThisRender;

      SERVER_FRONTLOAD_QUEUE = [];

      if (process.env.NODE_ENV !== 'production' && withLogging && frontloadsLeftToRun > 0) {
        log('frontloadServerRender WARNING', 'maxNestedFrontloadComponents (' + maxNestedFrontloadComponents + ') option in frontloadServerRender has been reached, ' + ('yet there are still ' + frontloadsLeftToRun + ' frontload child components to render. ') + 'I.e. you have more levels of nesting in your app than your configuration allows. ' + 'Server rendering will halt here and return the partially loaded result, which you probably don\'t want. ' + 'To fix this, either increase the levels of nesting allowed, or restructure your app so that it has fewer levels ' + 'of nested frontload components.');
        log('frontloadServerRender info', 'NOTE: as the logs show, the queue(s) are filled by the extra render pass that was one over maxNestedFrontloadComponents (' + maxNestedFrontloadComponents + '), ' + 'however they are NOT flushed, so the frontload functions DO NOT actually run.');
      }

      return incompleteRenderOutput;
    }

    return frontloadServerRenderWorker(render, { withLogging: withLogging, maxNestedFrontloadComponents: maxNestedFrontloadComponents }, renderNumber + 1, frontloadsInThisRender);
  });
}

function frontloadServerRender(render) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!options.maxNestedFrontloadComponents) {
    options.maxNestedFrontloadComponents = 1;
  }

  return frontloadServerRenderWorker(render, options);
}